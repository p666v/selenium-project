package ru.buttonone.documents;

public class XPathDoc {
    public static void main(String[] args) {
        /**
         *     ФУНКЦИИ XPATH:
         * -------------------------------------------------------------------------------------------------------------
         *  //div[text()='Hello, World!']"              Выбор текстового содержимого
         *  //div[contains(text(),'part of the text')]  Выбор элемента, содержащего указанный текст
         *  //div[starts-with(text(),'Welcome')]        Выбор элемента, у которого текст начинается с указанной строки
         *  //div[ends-with(text(),'Welcome')]          Выбор элемента, у которого текст оканчивается с указанной строки
         *  //div[@id='username']"                      Выбор элемента по значению атрибута
         *  //mg[starts-with(@src,'logo')]              Выбор любого рисунка с src-атрибутом, который начинается со значения ‘logo’
         *
         *  text()             Возвращает текстовое содержимое элемента
         *  count()            Возвращает количество элементов, соответствующих указанному выражению
         *  normalize-space()  Удаляет лишние пробелы из строки и заменяет последовательности пробелов на одиночные пробелы
         *  starts-with(x,y)   Проверяет, начинается ли строка с x-y
         *  contains(x,y)      Проверяет, содержит ли строка x-y
         *  last()             Возвращает последнюю позицию элемента в выборке
         *  position()         Возвращает позицию текущего элемента в выборке
         *  name()             Возвращает имя текущего элемента
         *  sum()              Суммирует значения элементов выборки
         *  string()           Преобразует узел в строку
         *  lower-case()       Преобразует текст в нижний регистр
         *  @attribute         Выбирает значение указанного атрибута
         *  concat()           Объединяет две или более строки
         *  string-length()    Возвращает длину строки
         *  substring()        Возвращает подстроку из строки, начиная с указанной позиции
         *
         *
         *     ОСИ XPATH
         * -------------------------------------------------------------------------------------------------------------
         *  /ancestor::              Выбирает всех предков текущего узла
         *  /ancestor-or-self::      Выбирает всех предков текущего узла и сам текущий узел
         *  /attribute::             Выбирает все атрибуты текущего узла
         *  /child::                 Выбирает всех прямых потомков текущего узла
         *  /descendant::            Выбирает всех потомков текущего узла
         *  /descendant-or-self::    Выбирает всех потомков текущего узла и сам текущий узел
         *  /following::             Выбирает все элементы в документе после закрывающего тега текущего узла
         *  /following-sibling::     Выбирает все элементы одного уровня после текущего узла
         *  /namespace::             Выбирает все узлы пространства имен текущего узла
         *  /parent:: или /..        Выбирает родителя текущего узла
         *  /preceding::             Выбирает все узлы, которые появляются перед текущим узлом, за исключением предков, узлов атрибутов и пространства имен
         *  /preceding-sibling::     Выбирает все элементы одного уровня до текущего узла
         *  /self::                  Выбирает текущий узел
         *
         *
         *     Базовый синтаксис XPath для парсинга элементов:
         *--------------------------------------------------------------------------------------------------------------
         *  1) *     — Выбрать любой элемент.
         *  2) []    — Найти конкретный элемент. Пример: //li[1]имя_узла — Выбирает все узлы с указанным именем узла. Пример: div, p и т.д.
         *  3) /     — Ищет от корневого узла html. Пример: /html/body/div[1]/h1
         *  4) //    — Ищет узлы в документе от текущего узла, который соответствует выбору, независимо от того, где они находятся. Пример:
         *  5) .     — Ищет текущий узел.
         *  6) ..    — Ищет родителя текущего узла.
         *  7) @     — Ищет нужный атрибут. Пример: //p[@value="2008"]
         *
         *
         *    EXAMPLES XPATH
         *--------------------------------------------------------------------------------------------------------------
         *  //div[@class='container']//ancestor::body               Выбирает все предки (включая родителя) узлов <div> с классом 'container' до корневого узла <body>.
         *  //p[@id='paragraph']//ancestor-or-self::div             Выбирает текущий узел <p> с id 'paragraph' и все его предки, включая сам узел <p>.
         *  //div[@class='example']/attribute::id                   Выбирает все атрибуты id в документе.
         *  //ul[@class='menu']/child::li                           Выбирает всех прямых потомков <li> узла <ul> с классом 'menu'.
         *  //div[@id='container']//descendant::a                   Выбирает всех потомков <a> узла <div> с id 'container'.
         *  //span[@class='highlight']//descendant-or-self::text()  Выбирает текущий узел <span> с классом 'highlight' и все его потомки, включая текстовые узлы.
         *  //h2[@id='title']/following::p                          Выбирает все элементы <p>, которые идут после узла <h2> с id 'title'.
         *  //li[@class='item']/following-sibling::li               Выбирает все элементы <li>, которые идут на том же уровне после узла <li> с классом 'item'.
         *  //namespace::*                                          Выбирает все узлы пространства имен текущего узла.
         *  //span[@class='child']/parent::div                      Выбирает родительский узел <div> для узла <span> с классом 'child'.
         *  //p[@class='paragraph']/preceding::h3                   Выбирает все узлы <h3>, которые идут перед узлом <p> с классом 'paragraph'.
         *  //li[@id='current']/preceding-sibling::li               Выбирает все элементы <li>, которые идут на том же уровне перед узлом <li> с id 'current'.
         *  //button[@disabled]/self::button                        Выбирает текущий узел <button> с атрибутом 'disabled'.
         *
         *  //a                                   Выберите все элементы в документе
         *  //a[@class='active']                  Выберите все элементы, у которых атрибут class равен "active"
         *  //input[@type='checkbox']             Выберите все элементы input, у которых атрибут type равен "checkbox"
         *  //input[@type='text']                 Выберите все элементы input с атрибутом type равным "text"
         *  //p[contains(text(), 'Lorem')]        Выберите все элементы, у которых текст содержит слово "Lorem"
         *  //div[count(p) > 3]                   Выберите все элементы, у которых количество дочерних элементов больше
         *  //a[starts-with(@href, 'https://')]   Выберите все элементы, у которых атрибут href начинается с "https://"
         *  //input[matches(@value, '^\d+$')]     Выберите все элементы input, у которых атрибут value содержит только цифры
         *  //p[@value="01/2008"]                 Выбирает все элементы p, у которых есть атрибут value со значением "01/2008"
         *  //p[@value]                           Выбирает все элементы p, у которых есть атрибут value
         *  //p/text()                            Выделит все текстовые узлы внутри всех элементов p
         *  //div[not(p)]                         Выберите все элементы, у которых не существует дочернего элемента
         *  /div/p[position()<3]                  Выбирает первые два элемента p, которые являются прямыми потомками элемента div
         *  //tag[position()=1]                   Выбирает первый элемент с тегом "tag"
         *  //div/ul/li[1]                        Выбирает первый элемент li, который является прямым потомком элемента ul в div
         *  //li[a]                               Выделяет элементы li, в которых есть элемент a
         *  //li[last()]                          Выделяет последний элемент li в документе
         *  //a | //h2                            Выделить все элементы a и h2 с помощью оператора объединения |
         *  //tag[@value > 9]                     Получить узлы tag, value которых больше 9-ти.
         *  //div[note[@value > 9]]/а             Получить только имена узлов, value которых больше 9-ти
         *  //div[4]/h2[text() = "Текст"]         Выделит четвертый элемент div, h2 которого содержит слово: Текст
         *  //div/note[last()]                    Выбирает последний элемент note, который является прямым потомком элемента div
         *  //div/note[last()-1]                  Выбирает предпоследний элемент note, который является прямым потомком элемента div
         *  //*[@id]                              Выберите все элементы с атрибутом id
         *  //div[contains(@class, 'content')]/p  Выберите все элементы, которые являются дочерними элементами с классом "content"
         *  //img[contains(@src, 'logo')]         Выберите все элементы , у которых атрибут src содержит слово "logo"
         *  //*[@href[contains(text(), '.pdf')]]  Выберите все элементы со значением атрибута href, оканчивающимся на .pdf
         *  //*[@data-toggle='modal']             Выберите все элементы с атрибутом data-toggle и значением "modal"
         *  //tag[@attribute>5]                   Выбирает все элементы с тегом "tag" и атрибутом "attribute", значение которого больше 5
         *  //tag[@attribute="value"]             Выбирает все элементы с тегом "tag" и атрибутом "attribute" со значением "value"
         *
         *
         */
    }
}
