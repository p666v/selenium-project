Базовый синтаксис XPath для парсинга элементов:

1) * — Выбрать любой элемент.

2) [] — Найти конкретный элемент. Пример: //li[1]

имя_узла — Выбирает все узлы с указанным именем узла. Пример: div, p и т.д.

3) / — Ищет от корневого узла html. Пример: /html/body/div[1]/h1

4) // — Ищет узлы в документе от текущего узла, который соответствует выбору, независимо от того, где они находятся. Пример:

5) . — Ищет текущий узел.

6) .. — Ищет родителя текущего узла.

7) @ — Ищет нужный атрибут. Пример: //p[@value="2008"]


Общие функции XPath
Язык XPath имеет набор встроенных функций, которые позволяют осуществлять различные операции с XML-документами.
Вот некоторые из основных функций XPath:

1) text() - возвращает текстовое содержимое элемента.

2) count() - возвращает количество элементов, соответствующих указанному выражению.

3) normalize-space() - удаляет лишние пробелы из строки и заменяет последовательности пробелов на одиночные пробелы.

4) starts-with(x,y) - проверяет, начинается ли строка с x-y.

5) contains(x,y) - проверяет, содержит ли строка x-y.

6) last() - возвращает последнюю позицию элемента в выборке.

7) position() - возвращает позицию текущего элемента в выборке.

8) name() - возвращает имя текущего элемента.

9) sum() - суммирует значения элементов выборки.

10) string() - преобразует узел в строку.

11) lower-case() - преобразует текст в нижний регистр.

12) @attribute - выбирает значение указанного атрибута.

13) concat() - объединяет две или более строки.

14) string-length() - возвращает длину строки.

15) substring() - возвращает подстроку из строки, начиная с указанной позиции.

Оси XPath
Ось в XPath - это специальная концепция, которая используется для указания направления движения при поиске элементов в документе. Оси позволяют выбирать элементы, которые относятся к определенным отношениям с другими элементами в дереве XML или HTML.

В XPath есть несколько осей, которые можно использовать при создании выражений:

1) child::note — Выбирает все узлы note, которые являются прямыми потомками текущего узла

2) attribute::date — Выбирает атрибут date текущего узла

3) child::* — Выбирает всех прямых потомков текущего узла

4) attribute::* — Выбирает все атрибуты текущего узла

5) child::text() — Выбирает все текстовые узлы текущего узла

6) child::node() — Выбирает всех прямых потомков текущего узла

7) descendant::note — Выбирает всех потомков note текущего узла

8) ancestor::note — Выбирает всех предков note текущего узла

9) ancestor-or-self::note — Выбирает всех предков note текущего узла, а также сам текущий узел, если это узел note

10) child::*/child::heading — Выбирает всех прямых потомков прямых потомков (“внуков") heading текущего узла

11) last() — Выделяет последний элемент в дереве.

Предикаты (Коллекции)
Предикаты — конструкции, которые используются для фильтрации элементов и выбора конкретных элементов с помощью определенных условий.

Вот несколько примеров использования предикатов в XPath для :

1) //a — Выберите все элементы в документе

2) //a[@class='active'] — Выберите все элементы, у которых атрибут class равен "active"

3) //input[@type='checkbox'] — Выберите все элементы input, у которых атрибут type равен "checkbox"

4) //input[@type='text'] — Выберите все элементы input с атрибутом type равным "text"

5) //p[contains(text(), 'Lorem')] — Выберите все элементы, у которых текст содержит слово "Lorem"

6) //div[count(p) > 3] — Выберите все элементы, у которых количество дочерних элементов больше 3

7) //a[starts-with(@href, 'https://')] — Выберите все элементы, у которых атрибут href начинается с "https://"

8) //input[matches(@value, '^\d+$')] — Выберите все элементы input, у которых атрибут value содержит только цифры

9) //p[@value="01/2008"] — Выбирает все элементы p, у которых есть атрибут value со значением "01/2008"

10) //p[@value] — Выбирает все элементы p, у которых есть атрибут value

11) //p/text() — Выделит все текстовые узлы внутри всех элементов p

12) //div[not(p)] — Выберите все элементы

, у которых не существует дочернего элемента

13) /div/p[position()<3] — Выбирает первые два элемента p, которые являются прямыми потомками элемента div

14) //tag[position()=1] — Выбирает первый элемент с тегом "tag"

15) /div/ul/li[1] — Выбирает первый элемент li, который является прямым потомком элемента ul в div

16) //li[a] — Выделяет элементы li, в которых есть элемент a

17) //li[last()] — Выделяет последний элемент li в документе

18) //a | //h2 - Выделить все элементы a и h2 с помощью оператора объединения |

19) //tag[@value > 9] — Получить узлы tag, value которых больше 9-ти.

20) //div[note[@value > 9]]/а — Получить только имена узлов, value которых больше 9-ти

21) //div[4]/h2[text() = "Текст"] — Выделит четвертый элемент div, h2 которого содержит слово: Текст

22) /div/note[last()] — Выбирает последний элемент note, который является прямым потомком элемента div

23) /div/note[last()-1] — Выбирает предпоследний элемент note, который является прямым потомком элемента div

24) //*[@id] — Выберите все элементы с атрибутом id

25) //div[contains(@class, 'content')]/p — Выберите все элементы, которые являются дочерними элементами с классом "content"

26) //img[contains(@src, 'logo')] — Выберите все элементы , у которых атрибут src содержит слово "logo"

27) //*[@href[contains(text(), '.pdf')]] — Выберите все элементы со значением атрибута href, оканчивающимся на .pdf

28) //*[@data-toggle='modal'] — Выберите все элементы с атрибутом data-toggle и значением "modal"

29) //tag[@attribute>5] — Выбирает все элементы с тегом "tag" и атрибутом "attribute", значение которого больше 5

30) //tag[@attribute="value"] — Выбирает все элементы с тегом "tag" и атрибутом "attribute" со значением "value"

Это лишь некоторые примеры запросов для получения данных. Существует много других комбинаций формирования запросов XPath.